import os
import hmac
import hashlib
from typing import Tuple

try:
    import bcrypt
    _HAS_BCRYPT = True
except Exception:
    _HAS_BCRYPT = False

# Parameters for PBKDF2 fallback
_PBKDF2_ALGO = "sha256"
_PBKDF2_ITERATIONS = 200_000
_SALT_BYTES = 16


def _pbkdf2_hash(password: bytes, salt: bytes, iterations: int = _PBKDF2_ITERATIONS) -> bytes:
    return hashlib.pbkdf2_hmac(_PBKDF2_ALGO, password, salt, iterations)


def hash_password(password: str) -> str:
    """Hash a senha e retorna uma string que identifica o esquema usado.
    Usa bcrypt quando disponível; caso contrário, usa PBKDF2-HMAC-SHA256.
    Levanta TypeError se password não for str.
    """
    if not isinstance(password, str):
        raise TypeError("password deve ser string")
    pw = password.encode("utf-8")

    if _HAS_BCRYPT:
        hashed = bcrypt.hashpw(pw, bcrypt.gensalt(rounds=12))
        return hashed.decode("utf-8")  # bcrypt já inclui salt e rounds no resultado
    else:
        salt = os.urandom(_SALT_BYTES)
        dk = _pbkdf2_hash(pw, salt, _PBKDF2_ITERATIONS)
        return f"pbkdf2_sha256${_PBKDF2_ITERATIONS}${salt.hex()}${dk.hex()}"


def verify_password(password: str, stored: str) -> bool:
    """Verifica se password corresponde ao hash armazenado.
    Suporta hashes bcrypt e o formato 'pbkdf2_sha256$iters$salt$hash'.
    """
    if not isinstance(password, str) or not isinstance(stored, str):
        raise TypeError("password e stored devem ser strings")
    pw = password.encode("utf-8")

    # bcrypt hash começam normalmente com $2b$ / $2a$ / $2y$
    if _HAS_BCRYPT and stored.startswith("$2"):
        try:
            return bcrypt.checkpw(pw, stored.encode("utf-8"))
        except Exception:
            return False

    # pbkdf2 fallback format: pbkdf2_sha256$iterations$salt_hex$dk_hex
    if stored.startswith("pbkdf2_sha256$"):
        try:
            _, iter_s, salt_hex, dk_hex = stored.split("$", 3)
            iterations = int(iter_s)
            salt = bytes.fromhex(salt_hex)
            expected = bytes.fromhex(dk_hex)
        except Exception:
            return False
        derived = _pbkdf2_hash(pw, salt, iterations)
        return hmac.compare_digest(derived, expected)

    # formato desconhecido
    raise ValueError("formato de hash desconhecido")


if __name__ == "__main__":
    # Exemplo rápido de uso
    pwd = "S3nh@F0rte!"
    h = hash_password(pwd)
    print("Hash:", h)
    print("Verifica (certo):", verify_password(pwd, h))
    print("Verifica (errado):", verify_password("outro", h))