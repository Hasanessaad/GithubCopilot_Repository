const express = require('express');
const bcrypt = require('bcrypt'); // npm install bcrypt
const router = express.Router();

const SALT_ROUNDS = 12; // ajustar conforme necessidade (10-12 é razoável)
const MAX_PASS_LENGTH = 1024;
const MAX_EMAIL_LENGTH = 254;

/**
 * Exemplo simples de armazenamento em memória.
 * Substituir por armazenamento persistente (DB) em produção.
 */
const users = new Map(); // key = email, value = { id, email, passwordHash }

/* Valida e normaliza entrada básica */
function validateCredentials(email, password) {
    if (typeof email !== 'string' || typeof password !== 'string') {
        throw new TypeError('Email e senha devem ser strings');
    }
    const e = email.trim().toLowerCase();
    const p = password;
    if (e.length === 0 || p.length === 0) {
        throw new RangeError('Email e senha são obrigatórios');
    }
    if (e.length > MAX_EMAIL_LENGTH || p.length > MAX_PASS_LENGTH) {
        throw new RangeError('Entrada excede tamanho permitido');
    }
    // validação simples de formato de email (não exaustiva)
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(e)) {
        throw new RangeError('Email inválido');
    }
    return { email: e, password: p };
}

/* Rota de registro (hash de senha com bcrypt) */
router.post('/register', async (req, res) => {
    try {
        const { email, password } = validateCredentials(req.body?.email, req.body?.password);
        if (users.has(email)) {
            return res.status(409).json({ error: 'Usuário já existe' });
        }
        const hash = await bcrypt.hash(password, SALT_ROUNDS);
        const id = String(Date.now()) + Math.random().toString(36).slice(2, 8);
        users.set(email, { id, email, passwordHash: hash });
        return res.status(201).json({ id, email });
    } catch (err) {
        if (err instanceof TypeError || err instanceof RangeError) {
            return res.status(400).json({ error: err.message });
        }
        return res.status(500).json({ error: 'Erro interno' });
    }
});

/* Rota de login (compara senha usando bcrypt.compare) */
router.post('/login', async (req, res) => {
    try {
        const { email, password } = validateCredentials(req.body?.email, req.body?.password);
        const user = users.get(email);

        // Para reduzir possibilidade de user enumeration timing attack,
        // compare mesmo se usuário não existir usando um hash dummy.
        const dummyHash = '$2b$12$..............................................'; // inválido, só placeholder
        const hashToCompare = user ? user.passwordHash : dummyHash;

        const match = await bcrypt.compare(password, hashToCompare);
        if (!user || !match) {
            return res.status(401).json({ error: 'Credenciais inválidas' });
        }

        // Autenticação bem-sucedida.
        // Em produção, gerar sessão segura ou JWT (aqui retorno simplificado).
        return res.json({ id: user.id, email: user.email, message: 'Login bem sucedido' });
    } catch (err) {
        if (err instanceof TypeError || err instanceof RangeError) {
            return res.status(400).json({ error: err.message });
        }
        return res.status(500).json({ error: 'Erro interno' });
    }
});

module.exports = router;