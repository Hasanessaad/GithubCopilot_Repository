from flask import Flask, request, render_template_string, after_this_request

app = Flask(__name__)

TEMPLATE = """
<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8">
  <title>Echo seguro</title>
</head>
<body>
  <h1>Enviar texto</h1>
  <form method="post" action="/">
    <input name="user_input" type="text" autocomplete="off" />
    <button type="submit">Enviar</button>
  </form>

  {% if user_input is not none %}
    <h2>Você enviou:</h2>
    <!-- Jinja2 faz escape automático aqui, evitando XSS -->
    <pre>{{ user_input }}</pre>
  {% endif %}
</body>
</html>
"""

@app.after_request
def set_security_headers(response):
    # Política de conteúdo restritiva para mitigar XSS
    response.headers["Content-Security-Policy"] = "default-src 'self'; script-src 'none'; object-src 'none';"
    response.headers["X-Content-Type-Options"] = "nosniff"
    response.headers["X-Frame-Options"] = "DENY"
    response.headers["Referrer-Policy"] = "no-referrer"
    return response

@app.route("/", methods=["GET", "POST"])
def index():
    # Lê o dado do usuário como string simples; não marca como safe em template
    user_input = None
    if request.method == "POST":
        # request.form retorna dados do form; mantenha o valor cru para que o template faça escape
        user_input = request.form.get("user_input", "")
        # opcional: limitar tamanho para evitar abuso
        if len(user_input) > 1000:
            user_input = user_input[:1000] + "…"
    return render_template_string(TEMPLATE, user_input=user_input)

if __name__ == "__main__":
    # Executar somente em ambiente de desenvolvimento; em produção use um servidor WSGI.
    app.run(host="127.0.0.1", port=5000, debug=False)