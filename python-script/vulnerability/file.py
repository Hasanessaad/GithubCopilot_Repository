from pathlib import Path
import sys
import os

BASE_DIR = Path(__file__).resolve().parent / "safe_files"
MAX_BYTES = 1_000_000  # limite de tamanho (1 MB)

def ensure_base_dir():
    BASE_DIR.mkdir(parents=True, exist_ok=True)

def read_file_safe(user_path: str) -> str:
    """Lê o arquivo somente se ele estiver dentro de BASE_DIR.
    user_path é tratado como relativo a BASE_DIR para evitar traversal.
    """
    if not isinstance(user_path, str):
        raise TypeError("caminho deve ser uma string")

    # Normaliza e resolve o caminho final (tratamos user_path como relativo)
    target = (BASE_DIR / user_path).resolve()

    base_resolved = BASE_DIR.resolve()
    try:
        common = os.path.commonpath([str(base_resolved), str(target)])
    except ValueError:
        # Diferentes drives no Windows -> negar
        raise PermissionError("acesso negado ao caminho solicitado")

    if common != str(base_resolved):
        raise PermissionError("acesso negado: fora do diretório permitido")

    if not target.exists():
        raise FileNotFoundError("arquivo não encontrado")
    if not target.is_file():
        raise PermissionError("não é um arquivo regular")

    size = target.stat().st_size
    if size > MAX_BYTES:
        raise PermissionError("arquivo muito grande")

    # Ler como texto UTF-8, substituindo bytes inválidos
    with target.open("rb") as f:
        data = f.read()
    return data.decode("utf-8", errors="replace")

if __name__ == "__main__":
    ensure_base_dir()
    # Exemplo: aceitar argumento de linha de comando ou pedir interativamente
    if len(sys.argv) > 1:
        path_input = sys.argv[1]
    else:
        path_input = input("Caminho relativo dentro de 'safe_files' (ENTER para exemplo): ").strip() or "example.txt"

    try:
        content = read_file_safe(path_input)
        print("=== Conteúdo do arquivo ===")
        print(content)
    except Exception as e:
        print("Erro:", e)