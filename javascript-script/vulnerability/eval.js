/**
 * Função insegura: executa código arbitrário usando eval().
 * NÃO usar com entradas vindas de usuários.
 */
function insecureEval(code) {
    if (typeof code !== 'string') {
        throw new TypeError('code deve ser uma string');
    }
    // AVISO: eval executa qualquer JS — pode causar RCE/XSS/privilege escalation.
    // Só para demonstração/local debugging com código confiável.
    return eval(code);
}

/**
 * Alternativa mais segura para avaliar expressões matemáticas simples
 * (apenas números, + - * / ^ e parênteses). Não usa eval nem Function.
 * Rejeita qualquer caractere inválido antes da avaliação.
 */
function safeEvalMath(expr) {
    if (typeof expr !== 'string') throw new TypeError('Expressão deve ser string');

    // Permite apenas dígitos, operadores + - * / ^ . ( ) e espaços
    if (!/^[0-9+\-*/^().\s]+$/.test(expr)) {
        throw new Error('Expressão contém caracteres não permitidos');
    }

    // Tokenização (identifica números, operadores e parênteses)
    const tokens = [];
    const s = expr.trim();
    let i = 0;
    let prevToken = null;
    while (i < s.length) {
        const ch = s[i];
        if (/\s/.test(ch)) { i++; continue; }

        if (/[0-9.]/.test(ch)) {
            let num = ch;
            i++;
            while (i < s.length && /[0-9.]/.test(s[i])) {
                num += s[i++];
            }
            if ((num.match(/\./g) || []).length > 1) throw new Error('Número inválido');
            tokens.push({ type: 'number', value: parseFloat(num) });
            prevToken = 'number';
            continue;
        }

        if (ch === '(' || ch === ')') {
            tokens.push({ type: 'paren', value: ch });
            prevToken = ch;
            i++;
            continue;
        }

        if (/[+\-*/^]/.test(ch)) {
            // Detecta '-' unário (negativo) quando aparece no início ou após outro operador ou '('
            if (ch === '-' && (prevToken === null || prevToken === 'operator' || prevToken === '(')) {
                tokens.push({ type: 'operator', value: 'u-' }); // unary minus
            } else {
                tokens.push({ type: 'operator', value: ch });
            }
            prevToken = 'operator';
            i++;
            continue;
        }

        throw new Error('Caractere inválido na expressão');
    }

    // Shunting-yard: converte para RPN
    const output = [];
    const ops = [];
    const prec = { '^': 4, '*': 3, '/': 3, '+': 2, '-': 2, 'u-': 5 };
    const rightAssoc = { '^': true, 'u-': true };

    for (const t of tokens) {
        if (t.type === 'number') {
            output.push(t);
        } else if (t.type === 'operator') {
            const o1 = t.value;
            while (ops.length) {
                const o2 = ops[ops.length - 1];
                if (o2.type === 'operator' &&
                    ((rightAssoc[o1] && prec[o1] < prec[o2.value]) ||
                     (!rightAssoc[o1] && prec[o1] <= prec[o2.value]))) {
                    output.push(ops.pop());
                } else break;
            }
            ops.push(t);
        } else if (t.type === 'paren') {
            if (t.value === '(') {
                ops.push(t);
            } else {
                // pop until '('
                let found = false;
                while (ops.length) {
                    const top = ops.pop();
                    if (top.type === 'paren' && top.value === '(') {
                        found = true;
                        break;
                    }
                    output.push(top);
                }
                if (!found) throw new Error('Parênteses desbalanceados');
            }
        }
    }
    while (ops.length) {
        const top = ops.pop();
        if (top.type === 'paren') throw new Error('Parênteses desbalanceados');
        output.push(top);
    }

    // Avaliação RPN
    const stack = [];
    for (const t of output) {
        if (t.type === 'number') {
            stack.push(t.value);
        } else if (t.type === 'operator') {
            if (t.value === 'u-') {
                if (stack.length < 1) throw new Error('Expressão inválida');
                const v = stack.pop();
                stack.push(-v);
            } else {
                if (stack.length < 2) throw new Error('Expressão inválida');
                const b = stack.pop();
                const a = stack.pop();
                let res;
                switch (t.value) {
                    case '+': res = a + b; break;
                    case '-': res = a - b; break;
                    case '*': res = a * b; break;
                    case '/':
                        if (b === 0) throw new Error('Divisão por zero');
                        res = a / b; break;
                    case '^': res = Math.pow(a, b); break;
                    default: throw new Error('Operador desconhecido');
                }
                stack.push(res);
            }
        }
    }
    if (stack.length !== 1) throw new Error('Expressão inválida');
    return stack[0];
}

// Exemplos / testes
// AVISO: insecureEval deve ser usado apenas com código confiável.
console.log('insecureEval("2+2") ->', insecureEval('2+2'));               // 4
console.log('safeEvalMath("2 + 3 * (4 - 1)") ->', safeEvalMath('2 + 3 * (4 - 1)')); // 11
console.log('safeEvalMath("-5 + 2") ->', safeEvalMath('-5 + 2')); // -3

module.exports = { insecureEval, safeEvalMath };